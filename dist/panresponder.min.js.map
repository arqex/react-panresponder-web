{"version":3,"file":"panresponder.min.js","sources":["../src/requestIdleCallback.js","../src/InteractionManager.js","../src/TouchHistoryMath.js","../src/PanResponder.js","../src/normalizeNativeEvent.js","../src/ResponderEventPlugin.js","../index.js"],"sourcesContent":["/**\r\n * Copyright (c) 2015-present, Nicolas Gallagher.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\n\r\nconst _requestIdleCallback = function(cb, options ) {\r\n  return setTimeout(() => {\r\n    const start = Date.now();\r\n    cb({\r\n      didTimeout: false,\r\n      timeRemaining() {\r\n        return Math.max(0, 50 - (Date.now() - start));\r\n      }\r\n    });\r\n  }, 1);\r\n};\r\n\r\nconst _cancelIdleCallback = function(id) {\r\n  clearTimeout(id);\r\n};\r\n\r\nconst isSupported = typeof window.requestIdleCallback !== 'undefined';\r\n\r\nconst requestIdleCallback = isSupported ? window.requestIdleCallback : _requestIdleCallback;\r\nconst cancelIdleCallback = isSupported ? window.cancelIdleCallback : _cancelIdleCallback;\r\n\r\nexport default requestIdleCallback;\r\nexport { cancelIdleCallback };","/**\r\n * Copyright (c) 2016-present, Nicolas Gallagher.\r\n * Copyright (c) 2015-present, Facebook, Inc.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n */\r\n\r\nimport requestIdleCallback, { cancelIdleCallback } from './requestIdleCallback';\r\n\r\nconst InteractionManager = {\r\n  Events: {\r\n    interactionStart: 'interactionStart',\r\n    interactionComplete: 'interactionComplete'\r\n  },\r\n\r\n  /**\r\n   * Schedule a function to run after all interactions have completed.\r\n   */\r\n  runAfterInteractions(task) {\r\n    let handle;\r\n\r\n    const promise = new Promise(resolve => {\r\n      handle = requestIdleCallback(() => {\r\n        if (task) {\r\n          resolve(task());\r\n        }\r\n      });\r\n    });\r\n    return {\r\n      then: promise.then.bind(promise),\r\n      done: promise.then.bind(promise),\r\n      cancel: () => {\r\n        cancelIdleCallback(handle);\r\n      }\r\n    };\r\n  },\r\n\r\n  /**\r\n   * Notify manager that an interaction has started.\r\n   */\r\n  createInteractionHandle() {\r\n    return 1;\r\n  },\r\n\r\n  /**\r\n   * Notify manager that an interaction has completed.\r\n   */\r\n  clearInteractionHandle(handle) {\r\n\t\t!handle &&  console.warn('Must provide a handle to clear.');\r\n  },\r\n\r\n  addListener: () => {}\r\n};\r\n\r\nexport default InteractionManager;","var TouchHistoryMath = {\r\n  /**\r\n   * This code is optimized and not intended to look beautiful. This allows\r\n   * computing of touch centroids that have moved after `touchesChangedAfter`\r\n   * timeStamp. You can compute the current centroid involving all touches\r\n   * moves after `touchesChangedAfter`, or you can compute the previous\r\n   * centroid of all touches that were moved after `touchesChangedAfter`.\r\n   *\r\n   * @param {TouchHistoryMath} touchHistory Standard Responder touch track\r\n   * data.\r\n   * @param {number} touchesChangedAfter timeStamp after which moved touches\r\n   * are considered \"actively moving\" - not just \"active\".\r\n   * @param {boolean} isXAxis Consider `x` dimension vs. `y` dimension.\r\n   * @param {boolean} ofCurrent Compute current centroid for actively moving\r\n   * touches vs. previous centroid of now actively moving touches.\r\n   * @return {number} value of centroid in specified dimension.\r\n   */\r\n  centroidDimension: function(\r\n    touchHistory,\r\n    touchesChangedAfter,\r\n    isXAxis,\r\n    ofCurrent\r\n  ) {\r\n    var touchBank = touchHistory.touchBank;\r\n    var total = 0;\r\n    var count = 0;\r\n\r\n    var oneTouchData =\r\n      touchHistory.numberActiveTouches === 1\r\n        ? touchHistory.touchBank[touchHistory.indexOfSingleActiveTouch]\r\n        : null;\r\n\r\n    if (oneTouchData !== null) {\r\n      if (\r\n        oneTouchData.touchActive &&\r\n        oneTouchData.currentTimeStamp > touchesChangedAfter\r\n      ) {\r\n        total +=\r\n          ofCurrent && isXAxis\r\n            ? oneTouchData.currentPageX\r\n            : ofCurrent && !isXAxis\r\n              ? oneTouchData.currentPageY\r\n              : !ofCurrent && isXAxis\r\n                ? oneTouchData.previousPageX\r\n                : oneTouchData.previousPageY;\r\n        count = 1;\r\n      }\r\n    } else {\r\n      for (var i = 0; i < touchBank.length; i++) {\r\n        var touchTrack = touchBank[i];\r\n        if (\r\n          touchTrack !== null &&\r\n          touchTrack !== undefined &&\r\n          touchTrack.touchActive &&\r\n          touchTrack.currentTimeStamp >= touchesChangedAfter\r\n        ) {\r\n          var toAdd = void 0; // Yuck, program temporarily in invalid state.\r\n          if (ofCurrent && isXAxis) {\r\n            toAdd = touchTrack.currentPageX;\r\n          } else if (ofCurrent && !isXAxis) {\r\n            toAdd = touchTrack.currentPageY;\r\n          } else if (!ofCurrent && isXAxis) {\r\n            toAdd = touchTrack.previousPageX;\r\n          } else {\r\n            toAdd = touchTrack.previousPageY;\r\n          }\r\n          total += toAdd;\r\n          count++;\r\n        }\r\n      }\r\n    }\r\n    return count > 0 ? total / count : TouchHistoryMath.noCentroid;\r\n  },\r\n\r\n  currentCentroidXOfTouchesChangedAfter: function(\r\n    touchHistory,\r\n    touchesChangedAfter\r\n  ) {\r\n    return TouchHistoryMath.centroidDimension(\r\n      touchHistory,\r\n      touchesChangedAfter,\r\n      true, // isXAxis\r\n      true\r\n    );\r\n  },\r\n\r\n  currentCentroidYOfTouchesChangedAfter: function(\r\n    touchHistory,\r\n    touchesChangedAfter\r\n  ) {\r\n    return TouchHistoryMath.centroidDimension(\r\n      touchHistory,\r\n      touchesChangedAfter,\r\n      false, // isXAxis\r\n      true\r\n    );\r\n  },\r\n\r\n  previousCentroidXOfTouchesChangedAfter: function(\r\n    touchHistory,\r\n    touchesChangedAfter\r\n  ) {\r\n    return TouchHistoryMath.centroidDimension(\r\n      touchHistory,\r\n      touchesChangedAfter,\r\n      true, // isXAxis\r\n      false\r\n    );\r\n  },\r\n\r\n  previousCentroidYOfTouchesChangedAfter: function(\r\n    touchHistory,\r\n    touchesChangedAfter\r\n  ) {\r\n    return TouchHistoryMath.centroidDimension(\r\n      touchHistory,\r\n      touchesChangedAfter,\r\n      false, // isXAxis\r\n      false\r\n    );\r\n  },\r\n\r\n  currentCentroidX: function(touchHistory) {\r\n    return TouchHistoryMath.centroidDimension(\r\n      touchHistory,\r\n      0, // touchesChangedAfter\r\n      true, // isXAxis\r\n      true\r\n    );\r\n  },\r\n\r\n  currentCentroidY: function(touchHistory) {\r\n    return TouchHistoryMath.centroidDimension(\r\n      touchHistory,\r\n      0, // touchesChangedAfter\r\n      false, // isXAxis\r\n      true\r\n    );\r\n  },\r\n\r\n  noCentroid: -1\r\n};\r\n\r\nexport default TouchHistoryMath;","/**\r\n * Copyright (c) 2013-present, Facebook, Inc.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n\r\nimport InteractionManager from './InteractionManager';\r\nimport TouchHistoryMath from './TouchHistoryMath';\r\n\r\nconst currentCentroidXOfTouchesChangedAfter = TouchHistoryMath.currentCentroidXOfTouchesChangedAfter;\r\nconst currentCentroidYOfTouchesChangedAfter = TouchHistoryMath.currentCentroidYOfTouchesChangedAfter;\r\nconst previousCentroidXOfTouchesChangedAfter = TouchHistoryMath.previousCentroidXOfTouchesChangedAfter;\r\nconst previousCentroidYOfTouchesChangedAfter = TouchHistoryMath.previousCentroidYOfTouchesChangedAfter;\r\nconst currentCentroidX = TouchHistoryMath.currentCentroidX;\r\nconst currentCentroidY = TouchHistoryMath.currentCentroidY;\r\n\r\n/**\r\n * `PanResponder` reconciles several touches into a single gesture. It makes\r\n * single-touch gestures resilient to extra touches, and can be used to\r\n * recognize simple multi-touch gestures.\r\n *\r\n * By default, `PanResponder` holds an `InteractionManager` handle to block\r\n * long-running JS events from interrupting active gestures.\r\n *\r\n * It provides a predictable wrapper of the responder handlers provided by the\r\n * [gesture responder system](docs/gesture-responder-system.html).\r\n * For each handler, it provides a new `gestureState` object alongside the\r\n * native event object:\r\n *\r\n * ```\r\n * onPanResponderMove: (event, gestureState) => {}\r\n * ```\r\n *\r\n * A native event is a synthetic touch event with the following form:\r\n *\r\n *  - `nativeEvent`\r\n *      + `changedTouches` - Array of all touch events that have changed since the last event\r\n *      + `identifier` - The ID of the touch\r\n *      + `locationX` - The X position of the touch, relative to the element\r\n *      + `locationY` - The Y position of the touch, relative to the element\r\n *      + `pageX` - The X position of the touch, relative to the root element\r\n *      + `pageY` - The Y position of the touch, relative to the root element\r\n *      + `target` - The node id of the element receiving the touch event\r\n *      + `timestamp` - A time identifier for the touch, useful for velocity calculation\r\n *      + `touches` - Array of all current touches on the screen\r\n *\r\n * A `gestureState` object has the following:\r\n *\r\n *  - `stateID` - ID of the gestureState- persisted as long as there at least\r\n *     one touch on screen\r\n *  - `moveX` - the latest screen coordinates of the recently-moved touch\r\n *  - `moveY` - the latest screen coordinates of the recently-moved touch\r\n *  - `x0` - the screen coordinates of the responder grant\r\n *  - `y0` - the screen coordinates of the responder grant\r\n *  - `dx` - accumulated distance of the gesture since the touch started\r\n *  - `dy` - accumulated distance of the gesture since the touch started\r\n *  - `vx` - current velocity of the gesture\r\n *  - `vy` - current velocity of the gesture\r\n *  - `numberActiveTouches` - Number of touches currently on screen\r\n *\r\n * ### Basic Usage\r\n *\r\n * ```\r\n *   componentWillMount: function() {\r\n *     this._panResponder = PanResponder.create({\r\n *       // Ask to be the responder:\r\n *       onStartShouldSetPanResponder: (evt, gestureState) => true,\r\n *       onStartShouldSetPanResponderCapture: (evt, gestureState) => true,\r\n *       onMoveShouldSetPanResponder: (evt, gestureState) => true,\r\n *       onMoveShouldSetPanResponderCapture: (evt, gestureState) => true,\r\n *\r\n *       onPanResponderGrant: (evt, gestureState) => {\r\n *         // The gesture has started. Show visual feedback so the user knows\r\n *         // what is happening!\r\n *\r\n *         // gestureState.d{x,y} will be set to zero now\r\n *       },\r\n *       onPanResponderMove: (evt, gestureState) => {\r\n *         // The most recent move distance is gestureState.move{X,Y}\r\n *\r\n *         // The accumulated gesture distance since becoming responder is\r\n *         // gestureState.d{x,y}\r\n *       },\r\n *       onPanResponderTerminationRequest: (evt, gestureState) => true,\r\n *       onPanResponderRelease: (evt, gestureState) => {\r\n *         // The user has released all touches while this view is the\r\n *         // responder. This typically means a gesture has succeeded\r\n *       },\r\n *       onPanResponderTerminate: (evt, gestureState) => {\r\n *         // Another component has become the responder, so this gesture\r\n *         // should be cancelled\r\n *       },\r\n *       onShouldBlockNativeResponder: (evt, gestureState) => {\r\n *         // Returns whether this component should block native components from becoming the JS\r\n *         // responder. Returns true by default. Is currently only supported on android.\r\n *         return true;\r\n *       },\r\n *     });\r\n *   },\r\n *\r\n *   render: function() {\r\n *     return (\r\n *       <View {...this._panResponder.panHandlers} />\r\n *     );\r\n *   },\r\n *\r\n * ```\r\n *\r\n * ### Working Example\r\n *\r\n * To see it in action, try the\r\n * [PanResponder example in RNTester](https://github.com/facebook/react-native/blob/master/RNTester/js/PanResponderExample.js)\r\n */\r\n\r\nconst PanResponder = {\r\n\r\n  /**\r\n   *\r\n   * A graphical explanation of the touch data flow:\r\n   *\r\n   * +----------------------------+             +--------------------------------+\r\n   * | ResponderTouchHistoryStore |             |TouchHistoryMath                |\r\n   * +----------------------------+             +----------+---------------------+\r\n   * |Global store of touchHistory|             |Allocation-less math util       |\r\n   * |including activeness, start |             |on touch history (centroids     |\r\n   * |position, prev/cur position.|             |and multitouch movement etc)    |\r\n   * |                            |             |                                |\r\n   * +----^-----------------------+             +----^---------------------------+\r\n   *      |                                          |\r\n   *      | (records relevant history                |\r\n   *      |  of touches relevant for                 |\r\n   *      |  implementing higher level               |\r\n   *      |  gestures)                               |\r\n   *      |                                          |\r\n   * +----+-----------------------+             +----|---------------------------+\r\n   * | ResponderEventPlugin       |             |    |   Your App/Component      |\r\n   * +----------------------------+             +----|---------------------------+\r\n   * |Negotiates which view gets  | Low level   |    |             High level    |\r\n   * |onResponderMove events.     | events w/   |  +-+-------+     events w/     |\r\n   * |Also records history into   | touchHistory|  |   Pan   |     multitouch +  |\r\n   * |ResponderTouchHistoryStore. +---------------->Responder+-----> accumulative|\r\n   * +----------------------------+ attached to |  |         |     distance and  |\r\n   *                                 each event |  +---------+     velocity.     |\r\n   *                                            |                                |\r\n   *                                            |                                |\r\n   *                                            +--------------------------------+\r\n   *\r\n   *\r\n   *\r\n   * Gesture that calculates cumulative movement over time in a way that just\r\n   * \"does the right thing\" for multiple touches. The \"right thing\" is very\r\n   * nuanced. When moving two touches in opposite directions, the cumulative\r\n   * distance is zero in each dimension. When two touches move in parallel five\r\n   * pixels in the same direction, the cumulative distance is five, not ten. If\r\n   * two touches start, one moves five in a direction, then stops and the other\r\n   * touch moves fives in the same direction, the cumulative distance is ten.\r\n   *\r\n   * This logic requires a kind of processing of time \"clusters\" of touch events\r\n   * so that two touch moves that essentially occur in parallel but move every\r\n   * other frame respectively, are considered part of the same movement.\r\n   *\r\n   * Explanation of some of the non-obvious fields:\r\n   *\r\n   * - moveX/moveY: If no move event has been observed, then `(moveX, moveY)` is\r\n   *   invalid. If a move event has been observed, `(moveX, moveY)` is the\r\n   *   centroid of the most recently moved \"cluster\" of active touches.\r\n   *   (Currently all move have the same timeStamp, but later we should add some\r\n   *   threshold for what is considered to be \"moving\"). If a palm is\r\n   *   accidentally counted as a touch, but a finger is moving greatly, the palm\r\n   *   will move slightly, but we only want to count the single moving touch.\r\n   * - x0/y0: Centroid location (non-cumulative) at the time of becoming\r\n   *   responder.\r\n   * - dx/dy: Cumulative touch distance - not the same thing as sum of each touch\r\n   *   distance. Accounts for touch moves that are clustered together in time,\r\n   *   moving the same direction. Only valid when currently responder (otherwise,\r\n   *   it only represents the drag distance below the threshold).\r\n   * - vx/vy: Velocity.\r\n   */\r\n\r\n  _initializeGestureState: function (gestureState) {\r\n    gestureState.moveX = 0;\r\n    gestureState.moveY = 0;\r\n    gestureState.x0 = 0;\r\n    gestureState.y0 = 0;\r\n    gestureState.dx = 0;\r\n    gestureState.dy = 0;\r\n    gestureState.vx = 0;\r\n    gestureState.vy = 0;\r\n    gestureState.numberActiveTouches = 0;\r\n    // All `gestureState` accounts for timeStamps up until:\r\n    gestureState._accountsForMovesUpTo = 0;\r\n  },\r\n\r\n  /**\r\n   * This is nuanced and is necessary. It is incorrect to continuously take all\r\n   * active *and* recently moved touches, find the centroid, and track how that\r\n   * result changes over time. Instead, we must take all recently moved\r\n   * touches, and calculate how the centroid has changed just for those\r\n   * recently moved touches, and append that change to an accumulator. This is\r\n   * to (at least) handle the case where the user is moving three fingers, and\r\n   * then one of the fingers stops but the other two continue.\r\n   *\r\n   * This is very different than taking all of the recently moved touches and\r\n   * storing their centroid as `dx/dy`. For correctness, we must *accumulate\r\n   * changes* in the centroid of recently moved touches.\r\n   *\r\n   * There is also some nuance with how we handle multiple moved touches in a\r\n   * single event. With the way `ReactNativeEventEmitter` dispatches touches as\r\n   * individual events, multiple touches generate two 'move' events, each of\r\n   * them triggering `onResponderMove`. But with the way `PanResponder` works,\r\n   * all of the gesture inference is performed on the first dispatch, since it\r\n   * looks at all of the touches (even the ones for which there hasn't been a\r\n   * native dispatch yet). Therefore, `PanResponder` does not call\r\n   * `onResponderMove` passed the first dispatch. This diverges from the\r\n   * typical responder callback pattern (without using `PanResponder`), but\r\n   * avoids more dispatches than necessary.\r\n   */\r\n  _updateGestureStateOnMove: function (gestureState, touchHistory) {\r\n    gestureState.numberActiveTouches = touchHistory.numberActiveTouches;\r\n    gestureState.moveX = currentCentroidXOfTouchesChangedAfter(touchHistory, gestureState._accountsForMovesUpTo);\r\n    gestureState.moveY = currentCentroidYOfTouchesChangedAfter(touchHistory, gestureState._accountsForMovesUpTo);\r\n    const movedAfter = gestureState._accountsForMovesUpTo;\r\n    const prevX = previousCentroidXOfTouchesChangedAfter(touchHistory, movedAfter);\r\n    const x = currentCentroidXOfTouchesChangedAfter(touchHistory, movedAfter);\r\n    const prevY = previousCentroidYOfTouchesChangedAfter(touchHistory, movedAfter);\r\n    const y = currentCentroidYOfTouchesChangedAfter(touchHistory, movedAfter);\r\n    const nextDX = gestureState.dx + (x - prevX);\r\n    const nextDY = gestureState.dy + (y - prevY);\r\n\r\n    // TODO: This must be filtered intelligently.\r\n    const dt = touchHistory.mostRecentTimeStamp - gestureState._accountsForMovesUpTo;\r\n    gestureState.vx = (nextDX - gestureState.dx) / dt;\r\n    gestureState.vy = (nextDY - gestureState.dy) / dt;\r\n\r\n    gestureState.dx = nextDX;\r\n    gestureState.dy = nextDY;\r\n    gestureState._accountsForMovesUpTo = touchHistory.mostRecentTimeStamp;\r\n  },\r\n\r\n  /**\r\n   * @param {object} config Enhanced versions of all of the responder callbacks\r\n   * that provide not only the typical `ResponderSyntheticEvent`, but also the\r\n   * `PanResponder` gesture state.  Simply replace the word `Responder` with\r\n   * `PanResponder` in each of the typical `onResponder*` callbacks. For\r\n   * example, the `config` object would look like:\r\n   *\r\n   *  - `onMoveShouldSetPanResponder: (e, gestureState) => {...}`\r\n   *  - `onMoveShouldSetPanResponderCapture: (e, gestureState) => {...}`\r\n   *  - `onStartShouldSetPanResponder: (e, gestureState) => {...}`\r\n   *  - `onStartShouldSetPanResponderCapture: (e, gestureState) => {...}`\r\n   *  - `onPanResponderReject: (e, gestureState) => {...}`\r\n   *  - `onPanResponderGrant: (e, gestureState) => {...}`\r\n   *  - `onPanResponderStart: (e, gestureState) => {...}`\r\n   *  - `onPanResponderEnd: (e, gestureState) => {...}`\r\n   *  - `onPanResponderRelease: (e, gestureState) => {...}`\r\n   *  - `onPanResponderMove: (e, gestureState) => {...}`\r\n   *  - `onPanResponderTerminate: (e, gestureState) => {...}`\r\n   *  - `onPanResponderTerminationRequest: (e, gestureState) => {...}`\r\n   *  - `onShouldBlockNativeResponder: (e, gestureState) => {...}`\r\n   *\r\n   *  In general, for events that have capture equivalents, we update the\r\n   *  gestureState once in the capture phase and can use it in the bubble phase\r\n   *  as well.\r\n   *\r\n   *  Be careful with onStartShould* callbacks. They only reflect updated\r\n   *  `gestureState` for start/end events that bubble/capture to the Node.\r\n   *  Once the node is the responder, you can rely on every start/end event\r\n   *  being processed by the gesture and `gestureState` being updated\r\n   *  accordingly. (numberActiveTouches) may not be totally accurate unless you\r\n   *  are the responder.\r\n   */\r\n  create: function (config) {\r\n    const interactionState = {\r\n      handle: null,\r\n    };\r\n    const gestureState = {\r\n      // Useful for debugging\r\n      stateID: Math.random(),\r\n    };\r\n    PanResponder._initializeGestureState(gestureState);\r\n    const panHandlers = {\r\n      onStartShouldSetResponder: function (e) {\r\n        return config.onStartShouldSetPanResponder === undefined ?\r\n          false :\r\n          config.onStartShouldSetPanResponder(e, gestureState);\r\n      },\r\n      onMoveShouldSetResponder: function (e) {\r\n        return config.onMoveShouldSetPanResponder === undefined ?\r\n          false :\r\n          config.onMoveShouldSetPanResponder(e, gestureState);\r\n      },\r\n      onStartShouldSetResponderCapture: function (e) {\r\n        // TODO: Actually, we should reinitialize the state any time\r\n        // touches.length increases from 0 active to > 0 active.\r\n        if (e.nativeEvent.touches.length === 1) {\r\n          PanResponder._initializeGestureState(gestureState);\r\n        }\r\n        gestureState.numberActiveTouches = e.touchHistory.numberActiveTouches;\r\n        return config.onStartShouldSetPanResponderCapture !== undefined ?\r\n          config.onStartShouldSetPanResponderCapture(e, gestureState) :\r\n          false;\r\n      },\r\n\r\n      onMoveShouldSetResponderCapture: function (e) {\r\n        const touchHistory = e.touchHistory;\r\n        // Responder system incorrectly dispatches should* to current responder\r\n        // Filter out any touch moves past the first one - we would have\r\n        // already processed multi-touch geometry during the first event.\r\n        if (gestureState._accountsForMovesUpTo === touchHistory.mostRecentTimeStamp) {\r\n          return false;\r\n        }\r\n        PanResponder._updateGestureStateOnMove(gestureState, touchHistory);\r\n        return config.onMoveShouldSetPanResponderCapture ?\r\n          config.onMoveShouldSetPanResponderCapture(e, gestureState) :\r\n          false;\r\n      },\r\n\r\n      onResponderGrant: function (e) {\r\n        if (!interactionState.handle) {\r\n          interactionState.handle = InteractionManager.createInteractionHandle();\r\n        }\r\n        gestureState.x0 = currentCentroidX(e.touchHistory);\r\n        gestureState.y0 = currentCentroidY(e.touchHistory);\r\n        gestureState.dx = 0;\r\n        gestureState.dy = 0;\r\n        if (config.onPanResponderGrant) {\r\n          config.onPanResponderGrant(e, gestureState);\r\n        }\r\n        // TODO: t7467124 investigate if this can be removed\r\n        return config.onShouldBlockNativeResponder === undefined ?\r\n          true :\r\n          config.onShouldBlockNativeResponder();\r\n      },\r\n\r\n      onResponderReject: function (e) {\r\n        clearInteractionHandle(interactionState, config.onPanResponderReject, e, gestureState);\r\n      },\r\n\r\n      onResponderRelease: function (e) {\r\n        clearInteractionHandle(interactionState, config.onPanResponderRelease, e, gestureState);\r\n        PanResponder._initializeGestureState(gestureState);\r\n      },\r\n\r\n      onResponderStart: function (e) {\r\n        const touchHistory = e.touchHistory;\r\n        gestureState.numberActiveTouches = touchHistory.numberActiveTouches;\r\n        if (config.onPanResponderStart) {\r\n          config.onPanResponderStart(e, gestureState);\r\n        }\r\n      },\r\n\r\n      onResponderMove: function (e) {\r\n        const touchHistory = e.touchHistory;\r\n        // Guard against the dispatch of two touch moves when there are two\r\n        // simultaneously changed touches.\r\n        if (gestureState._accountsForMovesUpTo === touchHistory.mostRecentTimeStamp) {\r\n          return;\r\n        }\r\n        // Filter out any touch moves past the first one - we would have\r\n        // already processed multi-touch geometry during the first event.\r\n        PanResponder._updateGestureStateOnMove(gestureState, touchHistory);\r\n        if (config.onPanResponderMove) {\r\n          config.onPanResponderMove(e, gestureState);\r\n        }\r\n      },\r\n\r\n      onResponderEnd: function (e) {\r\n        const touchHistory = e.touchHistory;\r\n        gestureState.numberActiveTouches = touchHistory.numberActiveTouches;\r\n        clearInteractionHandle(interactionState, config.onPanResponderEnd, e, gestureState);\r\n      },\r\n\r\n      onResponderTerminate: function (e) {\r\n        clearInteractionHandle(interactionState, config.onPanResponderTerminate, e, gestureState);\r\n        PanResponder._initializeGestureState(gestureState);\r\n      },\r\n\r\n      onResponderTerminationRequest: function (e) {\r\n        return config.onPanResponderTerminationRequest === undefined ?\r\n          true :\r\n          config.onPanResponderTerminationRequest(e, gestureState);\r\n      }\r\n    };\r\n    return {\r\n      panHandlers,\r\n      getInteractionHandle() {\r\n        return interactionState.handle;\r\n      },\r\n    };\r\n  }\r\n};\r\n\r\nfunction clearInteractionHandle( interactionState, callback, event, gestureState) {\r\n  if (interactionState.handle) {\r\n    InteractionManager.clearInteractionHandle(interactionState.handle);\r\n    interactionState.handle = null;\r\n  }\r\n  if (callback) {\r\n    callback(event, gestureState);\r\n  }\r\n}\r\n\r\nexport default PanResponder;","/**\n * Copyright (c) 2015-present, Nicolas Gallagher.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n\n /**\n\t* Updated by Javier Marquez - 2018\n\t*/\n\nconst emptyArray = [];\nconst emptyFunction = () => { };\n\nconst getRect = node => {\n\tif (node) {\n\t\tconst isElement = node.nodeType === 1 /* Node.ELEMENT_NODE */;\n\t\tif (isElement && typeof node.getBoundingClientRect === 'function') {\n\t\t\treturn node.getBoundingClientRect();\n\t\t}\n\t}\n};\n\n// Mobile Safari re-uses touch objects, so we copy the properties we want and normalize the identifier\nconst normalizeTouches = touches => {\n\tif (!touches) {\n\t\treturn emptyArray;\n\t}\n\n\treturn Array.prototype.slice.call(touches).map(touch => {\n\t\tconst identifier = touch.identifier > 20 ? touch.identifier % 20 : touch.identifier;\n\t\tlet rect;\n\n\t\treturn {\n\t\t\t_normalized: true,\n\t\t\tclientX: touch.clientX,\n\t\t\tclientY: touch.clientY,\n\t\t\tforce: touch.force,\n\t\t\tget locationX() {\n\t\t\t\trect = rect || getRect(touch.target);\n\t\t\t\treturn (rect && (touch.pageX - rect.left)) || undefined;\n\t\t\t},\n\t\t\tget locationY() {\n\t\t\t\trect = rect || getRect(touch.target);\n\t\t\t\treturn (rect && (touch.pageY - rect.top)) || undefined;\n\t\t\t},\n\t\t\tidentifier: identifier,\n\t\t\tpageX: touch.pageX,\n\t\t\tpageY: touch.pageY,\n\t\t\tradiusX: touch.radiusX,\n\t\t\tradiusY: touch.radiusY,\n\t\t\trotationAngle: touch.rotationAngle,\n\t\t\tscreenX: touch.screenX,\n\t\t\tscreenY: touch.screenY,\n\t\t\ttarget: touch.target,\n\t\t\t// normalize the timestamp\n\t\t\t// https://stackoverflow.com/questions/26177087/ios-8-mobile-safari-wrong-timestamp-on-touch-events\n\t\t\ttimestamp: Date.now()\n\t\t};\n\t});\n};\n\nfunction normalizeTouchEvent(nativeEvent) {\n\tconst changedTouches = normalizeTouches(nativeEvent.changedTouches);\n\tconst touches = normalizeTouches(nativeEvent.touches);\n\n\tconst preventDefault =\n\t\ttypeof nativeEvent.preventDefault === 'function'\n\t\t\t? nativeEvent.preventDefault.bind(nativeEvent)\n\t\t\t: emptyFunction;\n\tconst stopImmediatePropagation =\n\t\ttypeof nativeEvent.stopImmediatePropagation === 'function'\n\t\t\t? nativeEvent.stopImmediatePropagation.bind(nativeEvent)\n\t\t\t: emptyFunction;\n\tconst stopPropagation =\n\t\ttypeof nativeEvent.stopPropagation === 'function'\n\t\t\t? nativeEvent.stopPropagation.bind(nativeEvent)\n\t\t\t: emptyFunction;\n\n\tconst event = {\n\t\t_normalized: true,\n\t\tbubbles: nativeEvent.bubbles,\n\t\tcancelable: nativeEvent.cancelable,\n\t\tchangedTouches,\n\t\tdefaultPrevented: nativeEvent.defaultPrevented,\n\t\tidentifier: undefined,\n\t\tlocationX: undefined,\n\t\tlocationY: undefined,\n\t\tpageX: nativeEvent.pageX,\n\t\tpageY: nativeEvent.pageY,\n\t\tpreventDefault,\n\t\tstopImmediatePropagation,\n\t\tstopPropagation,\n\t\ttarget: nativeEvent.target,\n\t\t// normalize the timestamp\n\t\t// https://stackoverflow.com/questions/26177087/ios-8-mobile-safari-wrong-timestamp-on-touch-events\n\t\ttimestamp: Date.now(),\n\t\ttouches,\n\t\ttype: nativeEvent.type,\n\t\twhich: nativeEvent.which\n\t};\n\n\tif (changedTouches[0]) {\n\t\tevent.identifier = changedTouches[0].identifier;\n\t\tevent.pageX = changedTouches[0].pageX;\n\t\tevent.pageY = changedTouches[0].pageY;\n\t\tevent.locationX = changedTouches[0].locationX;\n\t\tevent.locationY = changedTouches[0].locationY;\n\t}\n\n\treturn event;\n}\n\nfunction normalizeMouseEvent(nativeEvent) {\n\tlet rect;\n\n\tconst touches = [\n\t\t{\n\t\t\t_normalized: true,\n\t\t\tclientX: nativeEvent.clientX,\n\t\t\tclientY: nativeEvent.clientY,\n\t\t\tforce: nativeEvent.force,\n\t\t\tidentifier: 0,\n\t\t\tget locationX() {\n\t\t\t\trect = rect || getRect(nativeEvent.target);\n\t\t\t\treturn (rect && (nativeEvent.pageX - rect.left)) || undefined;\n\t\t\t},\n\t\t\tget locationY() {\n\t\t\t\trect = rect || getRect(nativeEvent.target);\n\t\t\t\treturn (rect && (nativeEvent.pageY - rect.top)) || undefined;\n\t\t\t},\n\t\t\tpageX: nativeEvent.pageX,\n\t\t\tpageY: nativeEvent.pageY,\n\t\t\tscreenX: nativeEvent.screenX,\n\t\t\tscreenY: nativeEvent.screenY,\n\t\t\ttarget: nativeEvent.target,\n\t\t\ttimestamp: Date.now()\n\t\t}\n\t];\n\n\tconst preventDefault =\n\t\ttypeof nativeEvent.preventDefault === 'function'\n\t\t\t? nativeEvent.preventDefault.bind(nativeEvent)\n\t\t\t: emptyFunction;\n\tconst stopImmediatePropagation =\n\t\ttypeof nativeEvent.stopImmediatePropagation === 'function'\n\t\t\t? nativeEvent.stopImmediatePropagation.bind(nativeEvent)\n\t\t\t: emptyFunction;\n\tconst stopPropagation =\n\t\ttypeof nativeEvent.stopPropagation === 'function'\n\t\t\t? nativeEvent.stopPropagation.bind(nativeEvent)\n\t\t\t: emptyFunction;\n\n\treturn {\n\t\t_normalized: true,\n\t\tbubbles: nativeEvent.bubbles,\n\t\tcancelable: nativeEvent.cancelable,\n\t\tchangedTouches: touches,\n\t\tdefaultPrevented: nativeEvent.defaultPrevented,\n\t\tidentifier: touches[0].identifier,\n\t\tlocationX: touches[0].locationX,\n\t\tlocationY: touches[0].locationY,\n\t\tpageX: nativeEvent.pageX,\n\t\tpageY: nativeEvent.pageY,\n\t\tpreventDefault,\n\t\tstopImmediatePropagation,\n\t\tstopPropagation,\n\t\ttarget: nativeEvent.target,\n\t\ttimestamp: touches[0].timestamp,\n\t\ttouches: nativeEvent.type === 'mouseup' ? emptyArray : touches,\n\t\ttype: nativeEvent.type,\n\t\twhich: nativeEvent.which\n\t};\n}\n\n// TODO: how to best handle keyboard events?\nfunction normalizeNativeEvent(nativeEvent) {\n\tif (!nativeEvent || nativeEvent._normalized) {\n\t\treturn nativeEvent;\n\t}\n\tconst eventType = nativeEvent.type || '';\n\tconst mouse = eventType.indexOf('mouse') >= 0;\n\tif (mouse) {\n\t\treturn normalizeMouseEvent(nativeEvent);\n\t} else {\n\t\treturn normalizeTouchEvent(nativeEvent);\n\t}\n}\n\nexport default normalizeNativeEvent;","// based on https://github.com/facebook/react/pull/4303/files\n\nimport normalizeNativeEvent from './normalizeNativeEvent';\nimport ReactDOMUnstableNativeDependencies from 'react-dom/unstable-native-dependencies';\n\nconst { ResponderEventPlugin, ResponderTouchHistoryStore } = ReactDOMUnstableNativeDependencies;\n\n// On older versions of React (< 16.4) we have to inject the dependencies in\n// order for the plugin to work properly in the browser. This version still\n// uses `top*` strings to identify the internal event names.\n// https://github.com/facebook/react/pull/12629\nlet types = ResponderEventPlugin.eventTypes\nif (!types.responderMove.dependencies) {\n\n\tconst endDependencies = ['topTouchCancel', 'topTouchEnd', 'topMouseUp'];\n\tconst moveDependencies = ['topTouchMove', 'topMouseMove'];\n\tconst startDependencies = ['topTouchStart', 'topMouseDown'];\n\n  /**\n   * Setup ResponderEventPlugin dependencies\n   */\n\ttypes.responderMove.dependencies = moveDependencies;\n\ttypes.responderEnd.dependencies = endDependencies;\n\ttypes.responderStart.dependencies = startDependencies;\n\ttypes.responderRelease.dependencies = endDependencies;\n\ttypes.responderTerminationRequest.dependencies = [];\n\ttypes.responderGrant.dependencies = [];\n\ttypes.responderReject.dependencies = [];\n\ttypes.responderTerminate.dependencies = [];\n\ttypes.moveShouldSetResponder.dependencies = moveDependencies;\n\ttypes.selectionChangeShouldSetResponder.dependencies = ['topSelectionChange'];\n\ttypes.scrollShouldSetResponder.dependencies = ['topScroll'];\n\ttypes.startShouldSetResponder.dependencies = startDependencies;\n}\n\nlet lastActiveTouchTimestamp = null;\n\nconst originalExtractEvents = ResponderEventPlugin.extractEvents;\nResponderEventPlugin.extractEvents = (topLevelType, targetInst, nativeEvent, nativeEventTarget) => {\n\tconst hasActiveTouches = ResponderTouchHistoryStore.touchHistory.numberActiveTouches > 0;\n\tconst eventType = nativeEvent.type;\n\n\tlet shouldSkipMouseAfterTouch = false;\n\tif (eventType.indexOf('touch') > -1) {\n\t\tlastActiveTouchTimestamp = Date.now();\n\t} else if (lastActiveTouchTimestamp && eventType.indexOf('mouse') > -1) {\n\t\tconst now = Date.now();\n\t\tshouldSkipMouseAfterTouch = now - lastActiveTouchTimestamp < 250;\n\t}\n\n\tif (\n\t\t// Filter out mousemove and mouseup events when a touch hasn't started yet\n\t\t((eventType === 'mousemove' || eventType === 'mouseup') && !hasActiveTouches) ||\n\t\t// Filter out events from wheel/middle and right click.\n\t\t(nativeEvent.button === 1 || nativeEvent.button === 2) ||\n\t\t// Filter out mouse events that browsers dispatch immediately after touch events end\n\t\t// Prevents the REP from calling handlers twice for touch interactions.\n\t\t// See #802 and #932.\n\t\tshouldSkipMouseAfterTouch\n\t) {\n\t\treturn;\n\t}\n\n\tconst normalizedEvent = normalizeNativeEvent(nativeEvent);\n\n\treturn originalExtractEvents.call(\n\t\tResponderEventPlugin,\n\t\ttopLevelType,\n\t\ttargetInst,\n\t\tnormalizedEvent,\n\t\tnativeEventTarget\n\t);\n};\n\nexport default ResponderEventPlugin;","import PanResponder from './src/PanResponder'\nimport ResponderEventPlugin from './src/ResponderEventPlugin'\nimport { injectEventPluginsByName } from 'react-dom/unstable-native-dependencies'\n\n// Add responder events\ninjectEventPluginsByName({ ResponderEventPlugin })\n\nexport default PanResponder"],"names":["isSupported","window","requestIdleCallback","cb","options","setTimeout","start","Date","now","didTimeout","timeRemaining","Math","max","cancelIdleCallback","id","clearTimeout","InteractionManager","Events","interactionStart","interactionComplete","runAfterInteractions","task","handle","promise","Promise","resolve","then","bind","done","cancel","createInteractionHandle","clearInteractionHandle","console","warn","addListener","TouchHistoryMath","centroidDimension","touchHistory","touchesChangedAfter","isXAxis","ofCurrent","touchBank","total","count","oneTouchData","numberActiveTouches","indexOfSingleActiveTouch","touchActive","currentTimeStamp","currentPageX","currentPageY","previousPageX","previousPageY","i","length","touchTrack","noCentroid","currentCentroidXOfTouchesChangedAfter","currentCentroidYOfTouchesChangedAfter","previousCentroidXOfTouchesChangedAfter","previousCentroidYOfTouchesChangedAfter","currentCentroidX","currentCentroidY","PanResponder","_initializeGestureState","gestureState","moveX","moveY","x0","y0","dx","dy","vx","vy","_accountsForMovesUpTo","_updateGestureStateOnMove","movedAfter","prevX","x","prevY","y","nextDX","nextDY","dt","mostRecentTimeStamp","create","config","interactionState","stateID","random","panHandlers","onStartShouldSetResponder","e","undefined","onStartShouldSetPanResponder","onMoveShouldSetResponder","onMoveShouldSetPanResponder","onStartShouldSetResponderCapture","nativeEvent","touches","onStartShouldSetPanResponderCapture","onMoveShouldSetResponderCapture","onMoveShouldSetPanResponderCapture","onResponderGrant","onPanResponderGrant","onShouldBlockNativeResponder","onResponderReject","onPanResponderReject","onResponderRelease","onPanResponderRelease","onResponderStart","onPanResponderStart","onResponderMove","onPanResponderMove","onResponderEnd","onPanResponderEnd","onResponderTerminate","onPanResponderTerminate","onResponderTerminationRequest","onPanResponderTerminationRequest","getInteractionHandle","callback","event","emptyArray","emptyFunction","getRect","node","nodeType","getBoundingClientRect","normalizeTouches","Array","prototype","slice","call","map","touch","rect","identifier","_normalized","clientX","clientY","force","target","pageX","left","pageY","top","radiusX","radiusY","rotationAngle","screenX","screenY","timestamp","normalizeNativeEvent","type","indexOf","preventDefault","stopImmediatePropagation","stopPropagation","bubbles","cancelable","changedTouches","defaultPrevented","locationX","locationY","which","normalizeMouseEvent","normalizeTouchEvent","ResponderEventPlugin","ReactDOMUnstableNativeDependencies","ResponderTouchHistoryStore","types","eventTypes","responderMove","dependencies","endDependencies","moveDependencies","startDependencies","responderEnd","responderStart","responderRelease","responderTerminationRequest","responderGrant","responderReject","responderTerminate","moveShouldSetResponder","selectionChangeShouldSetResponder","scrollShouldSetResponder","startShouldSetResponder","lastActiveTouchTimestamp","originalExtractEvents","extractEvents","topLevelType","targetInst","nativeEventTarget","hasActiveTouches","eventType","shouldSkipMouseAfterTouch","button","normalizedEvent"],"mappings":"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"}